# Spring Boot笔记

## 1. 简介:

**引入**:Spring诞生时Java企业版的**轻量级代替品**。无需开发重量级的EJB，Spring为企业级Java开发提供了一种相对简单的方法：通过依赖注入和面向切面编程，用简单的对象实现了EJB的功能！\

注意:Spring是为了解决企业级应用开发的复杂性而创建的,简化开发!

Spring是如何简化开发的:

```
为了降低Java开发的复杂性,Spring采用了以下4种关键策略:
1.基于POJO的轻量级和最小侵入性编程,所有东西都是bean
2.通过IOC,依赖注入(DI)和面向接口实现松耦合
3.基于切面(Aop)和惯例进行声明式编程;
4.通过切面和模板减少样式代码,比如:RedisTemplate,xxxTemplate
```

**注意**：虽然Spring的组件代码是轻量级，但它的配置却是重量级的！

> 理解：这句话的意思就是说Spring的诞生就是解决了对象之间的依赖关系，让对象之间进行解耦合，这些都是Spring容器进行负责处理,虽然最终我们可以让对象之间解耦合,但是我们却要针对每一个对象去进行配置,项目越来越大这配置文件中的对象就越来越繁杂冗余!

来看Spring的发展史:

第一阶段:xml配置:

```
在Spring 1.x时代,使用Spring开发满眼都是xml配置的Bean,随着项目的扩大,我们需要把xml配置文件放到不同的配置文件里,在那个时候就需要在频繁的在开发的类和配置文件之间进行切换
```

第二阶段:注解配置:

```
在Spring 2.x时代,随着JDK1.5带来的注解支持,Spring提供了声明Bean的注解(比如:@Controller、@Service),大大减少了配置量,主要使用的方式是应用的基本配置(如配合数据库配置,扫描包路径)用xml配置文件,业务配置用注解!
```

第三阶段:java配置:

```
Spring 3.x引入了基于Java的配置能力,这是一种类似安全的可重构配置方式,可以代替XML,我们目前刚好处于这个时代,Spring 4.x和Spring Boot都推荐使用Java配置。
```

**结论**：

1. 所有这些配置都代表了开发时的损耗。因为在思考**Spring特性配置**和**解决业务问题**之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间！
2. 除此之外，项目的**依赖管理**也是件吃力不讨好的事情。决定项目里用哪些库就已经够让人头疼的了，你还要知道这些库的哪个**版本**和其他库不会有**冲突**，这难题实在太棘手，并且依赖管理也是一种损耗，添加依赖不是写应用程序代码，一旦选错了依赖的版本，随之而来的不兼容问题会是生产力杀手

> Spring Boot的产生就是简化Spring而诞生的!Spring Boot(微框架)=SpringMvc(控制器)+Spring(项目管理)

**概述**:Spring Boot简化了基于Spring的应用开发,只需要"run"就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供了开箱即用的设置（提供默认设置),这样我们就可以简单的开始使用,多数的Spring Boot应用只需要很少的Spring配置。

**Spring Boot 主要优点:**

1. 为所有Spring开发者提供更快的入门
2. **开箱即用**,提供各种默认配置来简化项目配置
3. 内嵌式容器简化Web项目
4. 没有冗余代码生成和XML配置的要求

```
理解:
1.spring Boot就是一个javaweb的开发框架,和springMVC类似,好处就在于简化开发:约定大于配置
2.springBoot基于Spring开发,但是要区别于该Spring Boot不是用来替代Spring的解决方案,而是跟Spring框架紧密集合用于提升Spring开发者体验的工具!
3.SpringBoot其实并不是什么新的框架,只是整合了所有的框架,只是默认配置了很多框架的使用方式;
```

> springBoot是一个javaWeb开发框架,主要目的就是简化开发,其本身并不是新框架而是整合了spring+SpringMVC!

## 2.简单运行

### 2.1 使用

**使用IDEA创建项目:**

1. 创建一个新项目
2. 选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现
3. 填写项目信息
4. 选择初始化的组件（初学勾选 Web 即可）
5. 填写项目路径
6. 等待项目构建成功

**创建完毕后会自动生成以下文件:**

1. 程序的主启动类
2. 一个application.properties 配置文件
3. 一个 测试类
4. 一个 pom.xml

**编写接口:**

1. 在主程序的同级目录下,新建一个Controller包,**注意一定要在同级目录下,否则识别不到**
2. 在包中新建一个HelloController类

```java
@RestController
public class HelloController {
 
    @RequestMapping("/")
    public String sayHello(){
        return "Hello Spring Boot!";
    }
}
```

3. 编写完毕然后运行主程序,然后在控制台就可以看见tomcat访问的端口号:

```
2021-09-17 20:37:10.218  INFO 16840 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path ''
```

4. 页面访问:

![image-20210917203813895](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917203813895.png)

**踩坑记录:**
1.我把新建的Controller的包放在其他路径下就是不放在主程序的同级目录下,那么就会发生404,如:


![四、创建第一个springboot项目_第一个_06](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2019021916031092.png)

解决办法是:

```java
@ComponentScan(basePackages = {"com.example.*"})//放在主程序的类上,表示覆写自定义包下的类,具体什么原理在自动装配原理那节详细讲
```

------

这种就是通过在IDEA工具进行启动访问,还有一种就是通过打包的方式运行

![image-20210917204039104](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204039104.png)

打成jar包后,我们在所在的文件夹下运行该jar包,就可以在任何地方进行访问了:

![image-20210917204143883](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204143883.png)

cmd运行:

![image-20210917204320615](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204320615.png)

> 这里之所以可以直接运行,是因为springBoot是内嵌式容器也就是tomcat!

总结:

1. spring Boot以约定大于配置的核心思想
2. 程序=数据结构+算法
3. spring Boot就是一个spring mvc框架
4. spring Boot的核心东西:自动装配!

还有在resource目录下的文件如果被spring boot识别成功就会有一个小图标,如:

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917205036312.png" alt="image-20210917205036312" style="zoom:200%;" />

还有做下笔记我们启动spring boot有启动图案,可以改的:

> 在resource下新建banner.txt文件,然后https://www.bootschool.net/ascii 这个网站生成,然后拷贝到文件中即可!

这里写一下微服务的概念:

**微服务就是把业务拆分成模块**

单体应用架构:把一个应用中的所有应用服务封装到一个应用;

微服务:把每个服务独立出来,把独立出来的功能元素的动态组合,

### 2.2 热部署

 即使修改了输出内容也要重启APP，非常麻烦！可以使用`spring-boot-devtools`来实现热部署！

**原理**:是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类（自己写的），称为  restart ClassLoader,这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间（5秒以内）

**使用**:

添加依赖包:

```xml-dtd
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
           <scope>true</scope>
</dependency>	
// 添加spring-boot-maven-plugin：
<build>
		<plugins>
		    <plugin>
	            <groupId>org.springframework.boot</groupId>
	            <artifactId>spring-boot-maven-plugin</artifactId>
	            <configuration>
	          		<!--fork :  如果没有该项配置，可能devtools不会起作用，即应用不会restart -->
	                <fork>true</fork>
	            </configuration>
	        </plugin>
		</plugins>
   </build>
```

在IDEA中通过快捷键使用`Ctrl+F9`进行手动编译!

## 3.自动装配原理

我们在创建编写spring boot的时候,就在思考是怎么运行起来的呢?新建一个spring boot项目又不像SSM那样进行整合和创建过多的依赖配置,我们新建后可以编写http接口访问?我们先来看pom.xml依赖开始:

### 3.1 pom.xml

```xml-dtd
 	<parent>
        <!--父依赖-->
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
```

可以发现这里是一个父依赖,主要管理项目的资源过滤及插件;

点进去,发现还有一个父依赖:

```xml-dtd
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.5.4</version>
</parent>
```

这里才是真正管理spring Boot应用里面所有依赖版本的地方,springBoot的版本控制中心!

> 总结:以后我们在导入依赖的时候不需要写对应的版本,因为当前pom依赖继承了父依赖,而在父依赖里已经定义了这些版本在父工程中!当然父工程中没有改依赖那么就需要手动配置版本了!

而再来看看启动器:spring-boot-starter:

```xml-dtd
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-web</artifactId> <!--启动器,说白了就是spring boot的启动场景,它就会帮我们导入web环境所有的依赖-->
            <!--这可以不要版本,因为是继承父依赖的-->
</dependency>
```

其中:

1. **spring-boot-starter-xxx**:就是spring-boot的场景启动器
2. **spring-boot-starter-web**:帮我们导入了web模块正常运行所依赖的组件;

**说明**:SpringBoot将所有的功能场景抽取出来,做成一个个的starter(启动器),只需要在项目中引入这些starter即可,所有相关的依赖都会导入进来,我们要用什么功能就导入什么样的场景启动器即可!

**理解**:在构建项目的时候,我们会勾选上web这个模块,然后在项目初始化的时候spring-boot就会将比如dispatcherServlet,servlet,都会导入到项目依赖中

> spring Boot会将所有的功能场景,都变成一个个的启动器,我们要使用什么功能就只需要找到对应的启动器就可以了`starter`

### 3.2 主启动类

```java
@SpringBootApplication  //来标注一个主程序类->说明这是一个Spring Boot应用
public class SpringbootProjectApplication {
    public static void main(String[] args) {
        //将springboot应用启动,这里以为是启动了一个方法没想到是启动了一个服务!
        SpringApplication.run(SpringbootProjectApplication.class, args);
    }
}
```

我们接下来就来分析一下这个主程序都干了些东西!

1. #### @SpringBootApplication

   作用:标注在某个类上说明这个类是springBoot的主配置类,Spring Boot就应该运行这个类的main方法来启动SpringBoot应用;

   进入这个注解可以发现上面还有很多注解:

   ```java
   @SpringBootConfiguration
   @EnableAutoConfiguration
   @ComponentScan(
       excludeFilters = {@Filter(
       type = FilterType.CUSTOM,
       classes = {TypeExcludeFilter.class}
   ), @Filter(
       type = FilterType.CUSTOM,
       classes = {AutoConfigurationExcludeFilter.class}
   )}
   )
   public @interface SpringBootApplication {
       // ......
   }
   ```

2. #### @ComponentScan

   这个注解在spring很重要,它对应XML配置中的元素,也就是扫描我们默认的包下的注解比如@Controller然后加载到我们IOC容器中!

   作用:自动扫描并加载符合条件的组件或者bean,将这个bean定义加载到IOC容器中,默认扫描当前类下的package

3. #### @SpringBootConfiguration

   作用:SpringBoot的配置类,标注在某个类上,表示这是一个SpringBoot的配置类,它表示就是支持JavaConfig形式的IOC容器的配置类

   ```java
   这个javaConfig形式的配置类就是跟我们平常使用的xml配置文件也是一样的,只不过两者配置方式不一样!给你们来个经典案例:
   javaconfig:
   @Configuration
   public class MockConfiguration{
       @Bean
       public MockService mockService(){
           return new MockServiceImpl(dependencyService());
       }
   }
   xml:
   <bean id="mockService" class="..MockServiceImpl">
      <propery name ="dependencyService" ref="dependencyService" />
   </bean>
   ```

   我们在点进去再看看:

   ```java
   //点击这个注解进入下面那个@Component
   @Configuration  //说百了就是支持JavaConfig的方式进行配置
   public @interface SpringBootConfiguration {...}
   
   @Component
   public @interface Configuration {...}
   ```

   这里的@Configuration说明这是一个配置类,配置类就是对应的Spring的xml配置文件;而再点进去得到的@Component这就说明该启动类本身也就是Spring中的一个组件而已,负责启动应用!

   ------

   我们再回到@SpringBootApplication注解中再看:

4. #### @EnableAutoConfiguration

   **开启自动配置功能**

   以前我们需要自己配置的东西,而现在SpringBoot可以自动帮我们配置;

   而@EbableAutoConfiguration告诉springBoot开启自动配置功能,这样自动配置才能生效;

   点击注解继续查看:

5. #### @AutoConfigurationPackage

   **自动配置包**

   ```java
   @Import(AutoConfigurationPackages.Registrar.class)
   public @interface AutoConfigurationPackage {...}
   ```

6. #### @Import

   这是Spring底层注解,给容器中导入一个组件;

   Registrar.class作用:将主启动类的所在包下面所有子包里面的所有组件扫描到Spring容器中;(所以为什么说要跟主程序同一个包才可以)

   我们在点击进去查看:

   ```java
   @Override
   public void registerBeanDefinitions(AnnotationMetadata metadata,
           BeanDefinitionRegistry registry) {
       register(registry, new PackageImport(metadata).getPackageName());
   }
   ```

   表示在默认的情况下就是将:主配置类(@SpringBootApplication)的所在包及其子包里面的部件扫描到Spring容器中!

   思考:这里也是扫描包加载到spring容器那么我们之前使用@ComponentScan的功能不就是重复了吗?

   > 比如说,我们使用Spring Data JPA,可能会在实体类上写@Entity注解,而这个注解是由@AutoConfigurationPackage扫描并加载,而我们平时开发用的@Controller/@Service...这些注解是由CompoentScan来扫描并加载的; 简单理解就是:两者扫描的对象都是不一致的!

   ------

   回到上一步:

7. #### @Import(AutoConfigurationImportSelector.class)

   **给容器导入组件**

   AutoConfigurationImportSelector:自动配置导入选择器,那么它会导入哪些组件的选择器呢?我们再点击这个源码查看:

   - 首先看下这里:

     ```java
     @Override
     //所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中
     	public String[] selectImports(AnnotationMetadata annotationMetadata) {
     		if (!isEnabled(annotationMetadata)) {
     			return NO_IMPORTS;
     		}
     		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
     		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
     	}
     ```
   
     表示加载元数据,表示把pom.xml文件中的数据加载进来,加载完后就进入下一步:
   
   - 获得自动配置实体:
   
     ```java
     protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
     		if (!isEnabled(annotationMetadata)) {
     			return EMPTY_ENTRY;
     		}
     		AnnotationAttributes attributes = getAttributes(annotationMetadata);
     		List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
     		configurations = removeDuplicates(configurations);
     		Set<String> exclusions = getExclusions(annotationMetadata, attributes);
     		checkExcludedClasses(configurations, exclusions);
     		configurations.removeAll(exclusions);
     		configurations = getConfigurationClassFilter().filter(configurations);
     		fireAutoConfigurationImportEvents(configurations, exclusions);
     		return new AutoConfigurationEntry(configurations, exclusions);
     	}
     ```
   
   - 然后点击其中的getCandidateConfigurations来获取候选的配置:
   
     ```java
     //获得所有的配置
     protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
         	//这里getSpringFactoriesLoaderFactoryClass()返回的是我们最开始看的启动自动导入配置文件的注解类,是:@EnableAutoConfiguration
     		List<String> configurations = SpringFactoriesLoader.SpringFactoriesLoader(getSpringFactoriesLoaderFactoryClass(),
     		//getBeanClassLoader这是一个加载器,相当于当前类的                                                                                  
     				getBeanClassLoader());
         	//这里提个彩蛋:这里断言可以如果发现不再就会给出提示说 META-INF/spring.factories这个文件找不到.那么这个有什么用呢?
     		Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you "
     				+ "are using a custom packaging, make sure that file is correct.");
     		return configurations;
     }
     //然后获取了哪些配置呢?就是这里
     //这里是getSpringFactoriesLoaderFactoryClass返回的是注解类:  意思是加载类,加载启动类2下的所有资源被导入
     protected Class<?> getSpringFactoriesLoaderFactoryClass() {
     		return EnableAutoConfiguration.class;
     }
     ```
   
   - 我们在点击`SpringFactoriesLoader`的静态方法`SpringFactoriesLoader`的源码查看:
   
     ```java
     //这是加载spring.factories这个自动配置文件的,而这里factorType表示加载了一个类这个类就是我们标注了@SpringBootApplication的这个类
     public static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {
     		ClassLoader classLoaderToUse = classLoader;
     		if (classLoaderToUse == null) {
     			classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();
     		}
         //获取类的名字
     		String factoryTypeName = factoryType.getName();
         //这里它又调用loadSpringFactories方法,获取默认的包名,为空则返回空的集合
     		return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());
     	}
     ```
   
   - 我们继续查看loadSpringFactories源码里看:
   
     ```java
     private static Map<String, List<String>> loadSpringFactories(ClassLoader classLoader) {
         //这里先去缓存里去加载
     		Map<String, List<String>> result = cache.get(classLoader);
     		if (result != null) {
     			return result;
     		}
     
     		result = new HashMap<>();
     		try {
                 //去获取一个资源 "META-INF/spring.factories",这里通过class类加载器去获取资源,将里面所有自动配置类加载进来
     			Enumeration<URL> urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);
                 //将获取的资源进行遍历,封装成为一个Properties
                 //判断有没有更多的元素,也即是从资源配置下找存在是否可以自动配置的东西,遍历完成之后封装为Properties供我们使用!
     			while (urls.hasMoreElements()) {
                     //如果有的话就放在url里面
     				URL url = urls.nextElement();
     				UrlResource resource = new UrlResource(url);
                     //把url这些资源加载到properties配置类里面,供我们使用
     				Properties properties = PropertiesLoaderUtils.loadProperties(resource);
     				for (Map.Entry<?, ?> entry : properties.entrySet()) {
     					String factoryTypeName = ((String) entry.getKey()).trim();
     					String[] factoryImplementationNames =
     							StringUtils.commaDelimitedListToStringArray((String) entry.getValue());
     					for (String factoryImplementationName : factoryImplementationNames) {
     						result.computeIfAbsent(factoryTypeName, key -> new ArrayList<>())
     								.add(factoryImplementationName.trim());
     					}
     				}
     			}
     
     			// Replace all lists with unmodifiable lists containing unique elements
     			result.replaceAll((factoryType, implementations) -> implementations.stream().distinct()
     					.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));
                 //放入到缓存里面
     			cache.put(classLoader, result);
     		}
     		catch (IOException ex) {
     			throw new IllegalArgumentException("Unable to load factories from location [" +
     					FACTORIES_RESOURCE_LOCATION + "]", ex);
     		}
     		return result;
     	}
     ```
   
   - 这里可以发现有个关键词:`FACTORIES_RESOURCE_LOCATION`这是常量对应的是:"META-INF/spring.factories",全局搜索:	


8. ## spring.factories(自动配置的核心文件)

   ![image-20210918114949624](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918114949624.png)
   
   根据源头我们找到了spring.factories然后将其打开,可以发现有很多的配置的文件,**这就是自动配置的根源之所在**!
   
   我们往下翻找到`Auto Configure(自动配置)`下的`WebMvcAutoConfiguration`这个类,打开看看:
   
9. #### WebMvcAutoConfiguration

   <img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918150043307.png" alt="image-20210918150043307" style="zoom: 80%;" />

   ​		

   @Configuration:表示这是Java的一个配置类

   @ConditionalOnClass:这是spring注解表示通过一些条件来判断是否注入
   
   我们继续在当前类里往下翻:
   
   ![image-20210918210321016](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918210321016.png)
   
   这个不难发现就是springMVC中的视图解析器,这个都已经自动配置了,还有一些过滤器啊什么的都是已经自动配置好了 	
   
   其中可以发现:这些一个个的都是Java Config配置类,而且都注入了一些Bean!
   
   **结论**:自动配置真正实现是从classPath中搜寻所有的`META-INF/spring.factories`配置文件,并将其中对应的`org.springframework.boot.autoconfigure.`包下的配置项,通过反射实例化为对应标注了`@Configuration`的JavaConfig形式的IOC容器配置类,然后将这些都汇总成为一个实例并加载到IOC容器中。
   
   
   
   -> 但是思考一个问题:既然是加载spring.factories里的所有的自动配置文件,那么为什么只生效了部分呢?
   
   比如我们随便点击一个没导入包的类进入:
   
   ![image-20210918230144508](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918230144508.png)

可以发现`@ConditionalOnClass`这个就是一个判断条件,判断条件成立才会加载这个类!比如说这里必须这个jar包存在那么这个类才会生效!

### 3.3 画图解析

![自动装配原理分析](https://gitee.com/miawei/pic-go-img/raw/master/imgs/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.png)



 ### 3.3 总结

结论:springBoot所有的自动配置都是在启动的时候扫描并加载:`spring.factories`所有的自动配置类都在这里面,但是不一定生效,要判断条件是否成立,只要导入了对应的start,就有对应的启动器了,有了启动器,我们自动装配就会生效,是因为在自动配置类中的`@ConditionalOnxxx`进行判断是否存在类或者包,有就存在!而生效就会去往容器中添加组件,而组件的默认值就会去对应加载的properties文件中去获取,而properties又跟springBoot配置文件进行绑定,而我们就可以手动的动态修改默认值,然后将其配置类添加到IOC容器!,然后我们通过主启动类上的`@SpringBootApplication`中的`@EnableAutoConfiguration`进行自动导入包中的`@Import(AutoConfigurationImportSelector)`进行加载所有自动配置类的候选,然后遍历所有的候选配置进行过滤,也就是说哪些类可以供我们使用,而这其实就是我们在自动配置类中声明的`@ConditionalOnxxx`进行判断是否生效,同时在,将生效的自动装配类通过一个个URL加载并封装到`Properties`中去,然后就会在配置类中通过`@Configuration`和`@Bean`注入到容器中供我们使用!

步骤:

1. SpringBoot在启动的时候会从类路径下的`META-INF/spring.factories`中获取指定的值(就是一个个的URL然后遍历封装到Properties);
2. 将这些值作为自动配置类的导入容器(这个容器就是在具体的配置类中的`@Configuration`和方法上的`@Bean`),自动配置类就生效,帮我们进行自动配置工作
3. 整个J2EE的整体解决方案和自动配置都在(xxxAutoConfiguration),就是给容器中导入这个场景需要的所有组件,并配置好这些组件
4. 解决方案和自动配置都在`spring-boot-autoconfigure-2.5.4.jar`这个包下
5. 它会把所有需要导入的组件,以类名(配置文件中都是全限定类名)的形式返回,这些组件就会被添加到容器
6. 容器中也会存在非常多的xxxAutoConfiguration的文件,就是这些类给容器中导入了这个场景需要的所有组件(`@Bean`),并自动配置@Configuration
7. 有了自动配置类,免去了我们手动编写配置注入功能组件等的工作!

## 4.启动类

我们来看一下启动类是如何运行的:

```java
public static void main(String[] args) {
        TimeInterval timer = DateUtil.timer();
        //将springboot应用启动
        SpringApplication.run(SpringbootProjectApplication.class, args);
        //启动日志
        Console.log("〓〓〓系统启动成功,耗时{}〓〓〓，当前时间是{}", timer.intervalPretty(), DateUtil.now());
    }
```

最初的时候以为就是运行个main方法,没想到这里就是直接运行了一个服务!

SpringApplication调用一个静态方法run,该方法里有个参数,一个是当前类,一个是当前命令行参数

SpringApplication这个类主要做了以下四件事情:

1. 推断应用的类型是普通的java项目还是web项目
2. 查找并加载所有可用初始化器 ， 设置到initializers属性中
3. 找出所有的应用程序监听器，设置到listeners属性中
4. 推断并设置main方法的定义类，找到运行的主类

查看构造器:

```java

public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {
    // ......
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    this.setInitializers(this.getSpringFactoriesInstances();
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
```

run方法流程分析:

![img](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicjafiawQLp9u8wc4ic1Mjy6OyfibzfjVofeL5pnS1NSFKVjlIg6neI9ySg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   跟着源码一起看效果会更好哦!

## 5.配置文件

在springBoot使用一个全局的配置文件,我们在创建springBoot的时候就会初始化一个文件`application.properties`这个文件,不过这个文件官方并不推荐,推荐的是另一种文件`yaml`格式的!

- application.properties
  - 语法结构:`key=value`
- application.yaml
  - 语法结构: `key:空格value`

**注意**:配置文件的名称是固定的!

因为springBoot底层就已经以这个名称写好了,说白了就是大家一起约定一下写一样的名字;

**解释**:

在pom.xml中的`spring-boot-starter-parent`中已经标注了:

```xml-dtd
<resource>
        <directory>${basedir}/src/main/resources</directory>
        <filtering>true</filtering>
        <includes>
          <include>**/application*.yml</include>
          <include>**/application*.yaml</include>
          <include>**/application*.properties</include>
        </includes>
</resource>
```

如果yaml跟properties同时存在,那么默认优先级高的是properties!

**配置文件的作用**:修改SpringBoot自动配置的默认值,因为SpringBoot在底层都给我们自动配置好了

### 5.1 yaml概述

**概述**:YAML是 "YAML Ain't a Markup Language" （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）

> 这种语言以数据为中心,而不是以标记语言为重点!

以前的配置文件,大多数都是使用xml来配置;比如一个简单的端口配置,我们来对比下yaml和xml:

传统的xml配置:

```xml
<servr>
	<port>8081</port>
</servr>
```

yaml配置:

```yaml
server:
	port: 8081
```

### 5.2 语法

1. ### 字面量:普通的值[数字,布尔值,字符串]

   ```yaml
   k: v
   ```

    字面量直接写在后面就可以,字符串默认不用加上双引号或者单引号

   **注意**:

   1. ""双引号,不会转义字符串里面的特殊字符,特殊字符会作为本身想表示的意思
      - 比如:name: "你好 \n 吗",然后输出:你好 换行 吗
   2. ''单引号,会转义特殊字符,特殊字符最终会变成和普通字符一样输出
      - 比如:name: '你好 \n 吗',然后输出:你好 \n 吗

   > 如果是数值是以0开头的,那么一定要加单引号,因为会默认取消第一个0!

2. ### 对象、Map(键值对)

   ```yaml
   # 对象、Map格式
   k：
   	v1: xx
   	v2: xx
   ```

   我们一般使用换行的形式来表达键值对的属性和值的关系,但是要注意缩进关系!比如:

   ```yaml
   student:
   	name: Miao
   	age: 3
   ```

   行内写法:

   ```yaml
   student: {name: Miao,age: 3}
   ```

3. ### 数组(List、set)

   用 - 值表示数组中的一个元素,比如:

   ```yaml
   zoo:
   	- cat
   	- dog
   	- pig
   ```

   行内写法:

   ```yaml
   zoo: [cat,dog,pig]
   ```

**注意事项**:

在yaml语法中对于空格是有着比较严格的要求!

1. 空格不能省略;
2. 以缩进来控制层级关系,只要左边对齐的一列数据都是同一个层级的
3. 属性和值的大小写都是十分敏感的;

### 5.3 注入

以前我们使用注入的时候使用的是Spring的@Value注解,它可以指定参数在Spring容器加载通过反射进行实例设值!但是这样耦合度很高,毕竟直接写在字段上,比如:

```java
public class Dog {
    @Value("缪威")
    private String name;
    @Value("21")
    private Integer age;
}
```

而yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！

1. 新建一个Dog:

   ```java
   @Component
   @Data
   public class Dog {
        private String name;
       private Integer age;
   }
   ```

2. 新建一个Pseron:

   ```java
   @Component
   @Data
   @ConfigurationProperties(prefix = "person")
   public class Person {
       private String name;
       private Integer age;
       private Boolean happy;
       private Date birth;
       private Map<String, Object> maps;
       private List<String> lists;
       private Dog dog;
   }
   ```

3. 在yaml配置文件进行配置

   ```yaml
   # 使用yaml配置注入的方式进行注入
   person:
     name: MiaoWei
     age: 21
     happy: false
     birth: 2000/08/14
     # map 键值对形式
     maps: {k1: v1,k2: v2}
     #list集合数组的形式
     lists:
       - code
       - 父母
       - music
     # 对象的形式
     dog:
       name: 缪威
       age: 21
   ```

4. 测试

   ```java
   @SpringBootTest
   class SpringbootProjectApplicationTests {
       @Autowired
       private Person person;
       @Test
       void contextLoads() {
           System.out.println(person);
       }
   }
   ```

5. 结果:

   ![image-20210920150833380](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920150833380.png)

   可以发现是自动注入进去了!

**注意**:

1. *@ConfigurationProperties*作用:

   - 将配置文件中配置的每一个属性的值,映射到这个组件中;告诉springBoot将本类中的所有属性和配置文件进行绑定,参数`prefix="person"`:则是将配置文件中的person下面的属性一一对应

2. 导入以上注解就会报出一个红色的提示:

   ![image-20210920151225909](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920151225909.png)

   解决办法:

   ```xml-dtd
   <!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 -->
   <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-configuration-processor</artifactId>
     <optional>true</optional>
   </dependency>
   ```

配置文件还可以使用站位符生成随机数:

```yaml
name: miaowei${random.uuid} # 随机uuid
```



------

以上加载yaml的配置文件,如果要加载properties文件,也是可以的:

1. 在`application.properties`里写注入值:

   ```properties
   name=缪威
   ```

2. 然后在我们的代码中指定加载`application.properties`文件

   ```java
   @Component
   @Data
   @PropertySource(value = "classpath:application.properties")
   public class Dog {
       @Value("${name}")  //这里使用SQEL表达式
       private String name;
       private Integer age;
   }
   ```

3. 测试:

   ```java
   @SpringBootTest
   class SpringbootProjectApplicationTests {
       @Autowired
       private Dog dog;
       @Test
       void contextLoads() {
           System.out.println(dog);
       }
   }
   ```

4. 运行:

   ![image-20210920153010506](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920153010506.png)

发现是可以注入成功的



**小结**:

@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图:

![image-20210920153428362](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920153428362.png)

1. @ConfigurationProperties只需要写一次即可,@Value则需要每个字段都添加
2. 松散绑定:比如我yml中写的`last-name`,这个和`lastName`是一样的,`-` 后面跟着的字母默认是大写的,这就是松散绑定!测试是可以正常注入的!
3. JSR303数据校验:这个就是我们可以在字段是增加一层过滤器验证,可以保证数据的合法性
4. 复杂类型封装:yml中可以封装对象,使用value就不支持

**结论**:

- 我们使用yml和配置properties都可以获取到值,强烈推荐yml

- 我们在业务中需要获取到配置文件中的某个值,就可以使用一下@Value
- 如果说我们专门编写一个JavaBean来和配置文件一一对应那么就直接选择@configurationProperties!

代码:

1. 使用@Value来获取指定配置文件中的某个值(这个配置文件可以是yaml也可以是properties)

   ```java
   @Component
   @Data
   @PropertySource(value = "classpath:application.yaml")
   public class Person {
       @Value("${student.name}")
       private String name;
   }
   //针对单个字段进行获取配置文件中的值
   ```

2. 使用@configurationProperties则是将指定节点中的节点一一对应映射

   ```java
   @Component
   @Data
   @ConfigurationProperties(prefix = "student")
   public class Person {
       private String lastName;
       private Integer age;
       private Boolean happy;
       private Date birth;
       private Map<String, Object> maps;
       private List<String> lists;
       private Dog dog;
   }
   //只要字段跟配置文件中的字段保持一致那么就会映射获取
   ```

   

> 这里记录一下对于Yaml文件注入到字符串

yaml:

```yaml
spring:
  # 邮件配置
  mail:
  	username: miaodawei8721@foxmail.com
```

测试类:

```java
@SpringBootTest
class BackstageProjectApplicationTests {
    @Value("#{'${spring.mail.username}'}")  //第一种方式
   // @Value("${spring.mail.username}")		第二种方式
    private String username;
    
    @Test
    public void send() {
        System.out.println(username);
    }
}
```

输出:

![image-20211028180237435](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211028180237435.png)

**注意**:注入的字符串不能是静态类型的!也就是说不能有static修饰的!

**踩坑**:如果注入的类本身注入到了容器,而我们想要快速的测试使用正常使用,那么记住不能直接new去调用方法去使用,而是用Spring的方式用@Autowired进行注入获取!否则一直都是null!

这是相关链接:https://www.tqwba.com/x_d/jishu/262058.html

### 5.4 加载位置

外部加载配置文件的方式十分多,我们选择最常用的即可:

![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDUoiazZ6ehegLG4doZK0uSJHribIqwVKiaNibSaYZSgjZf4kGzhLdGrkzzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这是springBoot的官方文档里描述配置文件的加载位置,扫描这些位置的application.properties或者application.yml文件作为springBoot的默认配置文件

**注意**:如果同时存在`application.properties`和`application.yml`那么前者的优先级高!

解释一下图中位置的描述:

```
优先级1:项目路径下的config文件夹配置文件
优先级2:项目路径下的配置文件
优先级3:资源路径下的config文件夹配置文件
优先级4:资源路径下配置文件
```

> 优先级从高到低,高优先级的配置会覆盖低优先级的配置;

SpringBoot会从这四个位置全部加载主配置文件;**进行互补配置**

测试:我在低配置的yml里添加参数,然后运行测试看是否能注入到:

这是这四个文件:

![image-20210920172738414](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920172738414.png)

然后我在优先级4哪里添加以下配置:

```yaml
student:
  name: 缪威
```

然后在pojo进行获取注入:

```java
@Data
@Component
@ConfigurationProperties(prefix = "student")
public class Person {
    private String name;
}
```

测试运行:

```java
@SpringBootTest
class SpringbootProjectApplicationTests {
    @Autowired
    private Person person;
    @Test
    void contextLoads() {
        System.out.println(person);
    }

}
```

结果:

![image-20210920173007446](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920173007446.png)

------

当然我们还可以指定外部配置文件,也就是说不需要以上的默认位置去加载:

> 我们还可以通过spring.config.location来改变默认的配置文件位置

项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高

```java
java -jar spring-boot-config.jar --spring.config.location=F:/application.properties
```

### 5.5 配置文件自动配置原理

我们在写yml配置文件的过程中在思考配置文件到底能写什么?怎么写?

在SpringBoot官方的文档中记录了大量的配置,但是我们无法全部记住

![img](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbD7ibqw837BhN1F7lHdAMhMmYNCYF2tSdvUGv0y3X48tzetuuYc8tUMLg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

接下来开始分析自动配置的原理

1. 我们还是从主启动类的注解进入找到`spring-factories`这个文件,因为自动装配的文件springBoot都存放在这里

   思考?配置文件到底能写什么跟spring-factories这之间的联系!

2. 我们在spring-factories里找到`HttpEncodingAutoConfiguration(Http编码自动配置)`来进行解释自动配置原理:

```java
//表示这是一个配置类,会被Spring接管、配置->javaConfig形式,跟@Bean搭配使用,跟直接在容器中写<bean>标签是一样的道理
@Configuration(proxyBeanMethods = false)
//将配置文件中的对应的值和ServerProperties绑定在一起修改默认值,并把ServerProperties加入到IOC容器中;
@EnableConfigurationProperties(ServerProperties.class)
//spring的底层注解:根据不同的条件,来判断当前配置或者类是否生效
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)  //如果这个类型不是web应用就直接无效
@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目是否存在这个类,SpringMVC中进行乱码解决的过滤器
@ConditionalOnProperty(prefix = "server.servlet.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置,不存在就走默认的
public class HttpEncodingAutoConfiguration {
	//他已经和SpringBoot的配置文件映射了
	private final Encoding properties;
	//只有一个有参构造器的情况下，参数的值就会从容器中拿
	public HttpEncodingAutoConfiguration(ServerProperties properties) {
		this.properties = properties.getServlet().getEncoding();
	}

	@Bean
	@ConditionalOnMissingBean
    //给容器中添加一个组件，这个组件的某些值需要从properties中获取
	//字符编码的过滤,然后添加到我们组件中
	public CharacterEncodingFilter characterEncodingFilter() {
		CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
		filter.setEncoding(this.properties.getCharset().name());
		filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST));
		filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE));
		return filter;
	}

	@Bean
	//下面这些都是些国际化
	public LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() {
		return new LocaleCharsetMappingsCustomizer(this.properties);
	}
	...

}
```

3. 我们点击`ServerProperties.class`这个类里面:

   ![image-20210920194007641](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920194007641.png)

   可以发现这个`ServlerProperties`绑定了配置文件下的server的所有东西,所以我们说这个配置文件能写什么东西是要去看这个对应的类中有哪些东西!

> 在我们配置文件中能够配置的东西,都存在一个固有的规律:就是以xxxProperties形式的配置类,而这个文件一般由xxxAutoConfiguration装载的,而大量的配置类里面默认装配了一些默认的属性,然后这个自动装配里面一般会去绑定配置了一个文件,就是通过properties的方式加载一些自定义的文件,而这个Properties文件又跟我们配置文件绑定	

**结论**:由xxxAutoConfiguration自动配置类自动帮我们装配东西,而自动装配就会去加载xxxProperties文件里的默认值,而xxxProperties又跟我们配置文件进行绑定,所以我们就可以使用自定义的配置了! 

一句话:根据当前不同的条件判断,决定了这个配置类是否生效!

- 一旦这个配置类生效那么就会给容器中添加各种组件
- 这些组件的属性是从对应的properties类中获取的,而properties这个类中的每一个属性又是和配置文件进行绑定的;
- 所有在配置文件中能配置的属性都是在xxxProperties类中封装的;
- 配置文件能配置什么就可以参照某个功能对应的这个属性类

> 这就是自动装配的原理!

再来记录一波:

1. SpringBoot启动就会加载大量的自动配置类
2. 我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中;
3. 我们再来看这个自动配置类中到底配置了哪些组件;(只要我们要用的组件存在其中我们就不需要再手动配置了)
4. 给容器中自动配置类添加组件的时候,会从properties类中获取某些属性,我们只需要在配置文件中指定这些属性的值即可;

```java
xxxAutoConfiguration:自动配置类,给容器中添加组件
xxxProperties:封装配置文件中相关属性,通过springBoot配置文件进行动态修改属性值
```

配置原理理解:

SpringBoot通过主启动类在启动的时候首先会扫描当前主程序下同级类中的注解并添加到容器中,然后开启自动配置容器去找到`META/INF/spring.factories`并加载大量的配置类,这些配置类提供我们大量场景需要的组件,而配置类中判断条件看是否满足生效,而生效就会去往容器中添加组件,而组件的默认值就会去对应加载的properties文件中去获取,而properties又跟springBoot配置文件进行绑定,而我们就可以手动的动态修改默认值,然后将其配置类添加到IOC容器!

------



> 我们学习springBoot一定要明白自动装配到底帮我们配置了什么?我们能不能修改?我们能修改哪些配置?我们能不能扩展?

- 向容器中自动配置组件,比如:xxxAutoconfiguration
- 自动配置类,封装配置文件的内容:xxxProperties

### 5.6 @Conditional

在研究自动配置类的时候可以看出基本上每个自动配置类上都会有一个注解就是@Conditional,它表示在一定条件下才能生效

作用:必须是@Conditional指定的条件成立,才给容器中添加组件,配置配里面的所有内容才生效

![image-20210920204453032](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920204453032.png)

> 那么多的自动配置类,必须在一定的条件下才能生效,也就是说我们加载了这么多的配置类,但不是所有的都生效了

但是这里又有一个思考问题:我们如何知道自己哪些配置类生效了呢?

我们可以通过启用`debug=true`属性;来让控制台打印自动配置报告,这样我们就知道哪些自动配置类生效;

```yaml
# 开启springBoot的调试类
debug: true
```

打印台参数解释:

1. Positive matches:自动配置类启用的:正匹配
2. Negative matches:,没有启动,没有匹配成功的自动配置类:负匹配
3. Unconditional classes:没有条件的类



## 6.JSR303数据校验

这个就是使用`@Validated`来校验数据!如果数据异常则会统一抛出异常,方便异常中心统一处理;

比如:

```java
@Component //注册bean
@ConfigurationProperties(prefix = "person")
@Validated  //数据校验
public class Person {

    @Email(message="邮箱格式错误") //name必须是邮箱格式
    private String age;
}
```

运行结果:

![image-20210920162655104](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920162655104.png)

常见的一些参数:

Bean Validation 中内置的 constraint:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/3145530-8ae74d19e6c65b4c)

 Hibernate Validator 附加的 constraint:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/3145530-10035c6af8e90a7c)



​	踩坑记录:

​	如果在字段添加校验注解比如@Email爆红不存在,那么就去检查一下是否存在对应的包:

![image-20210920162927402](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920162927402.png)

​	如果没有则引入一下依赖就可以了:

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

注意: 如果在校验类中接收的是对象那么就打`@Valid`,然后在这个对象里面再进行具体的校验,比如@NotNull!

![image-20211123110919964](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211123110919964.png)

> 如果要分组校验,那么可以参考这篇文章:https://www.cnblogs.com/wwjj4811/p/13806812.html
>
> 分组校验可理解为如:注册-这个对象可以为空 修改-这个对象不能为空,都是用的同一个对象那么这个就可以采用分组校验!

## 7.多环境切换

我们在开发过程中会遇到有多个环境,比如由开发环境,测试环境,每个环境的数据库等配置都是不一样的,那么我们如何进行不同的切换呢?

> 我们在在主配置文件编写的时候,文件名可以是application-{profile}.properties/yml,用来指定多个环境版本

**注**:profile是Spring对不同环境提供不同配置功能的支持,可以通过激活不同的环境版本,实现快速切换环境;

例如:

```yaml
application-test.properties # 代表测试环境配置
application-dev.properties # 代表开发环境配置
```

虽然有多个环境版本,但是springBoot不会直接启动这些配置文件,它默认使用`application.properties`主配置文件;而我们能做的就是通过配置进行选择激活:

```properties
# 比如在配置文件中指定使用dev环境,我们可以通过设置不同的端口号进行测试;
# 我们启动springBoot就可以看到已经切换到dev下的配置了
spring.profiles.active=dev
```

------

以上的都是用properties文件,每次切换版本啊环境都需要切换不同的配置文件,而yaml可以不需要创建多个配置文件:

```yaml
server:
  port: 8081
#选择要激活那个环境块
spring:
  profiles:
    active: prod
# 通过---三个中华线进行分割多个环境
---
server:
  port: 8083
spring:
  profiles: dev #配置环境的名称


---

server:
  port: 8084
spring:
  profiles: prod  #配置环境的名称
```

**注意**:如果yml和properties同时都配置了端口,并且没有激活其他环境,那么默认是会使用properties配置文件的!

> 这里记录一下一个配置文件引入另外一个配置文件

如果同一个环境有多个配置文件，可以通过**spirng.profiles.include**实现多配置文件

**注意**:这里导入的名字是application-xxx.yaml中的xxx

如:

```yaml
application.yaml
spring:
	profiles:
		include: druid
		
application-druid.yaml
```

这里配上详细链接:https://blog.csdn.net/xiaorui51/article/details/108452181



## 8.web资源源码解析

​	我们在写一个web项目的时候势必要引入相关的CSS、JS等文件，之前在springMVC可以在main下有一个webapp，我们以前都是将所有的页面导在这里面，但是对于springBoot来讲是没有webapp的，那么这个springBoot该如何处理呢？而我们现在的pom打包方式是为[jar](jar包可以直接运行，内嵌服务器，便于管理，而war包必须在tomcat服务器里才能运行，前者以普通项目打包，而后者是以webapp进行打包文件夹)的方式，那么这种方式在springBoot能不能引入写页面呢？好的接下来继续往下看看：

### 8.1 静态资源映射规则

SpringBoot对于静态资源的放置也是有规定的，就是说不能乱放，那么该怎么放呢？我们从自动装配的源码开始看起走：

在SpringBoot中,SpringMVC的web配置都在WebMvcAutoConfiguration这个配置类,然后我们在这里找到一个方法:`addResourceHandlers(添加资源处理)`

```java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    //如果有自动配置那么就会失效,而这个自动配置就是我们在配置文件手动修改
    if (!this.resourceProperties.isAddMappings()) {
        // 已禁用默认资源处理
        logger.debug("Default resource handling disabled");
        return;
    }
    //这是第一种方式:通过webjars去依赖路径下寻找
   addResourceHandler(registry, "/webjars/**", "classpath:/META-INF/resources/webjars/");
    //这是第二种方式:获取springBoot默认设置的资源访问路径
   addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {
       												//这里就是获取springBoot获取默认的资源文件夹路径
				registration.addResourceLocations(this.resourceProperties.getStaticLocations());
				if (this.servletContext != null) {
					ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION);
					registration.addResourceLocations(resource);
				}
			});
}
private void addResourceHandler(ResourceHandlerRegistry registry, String pattern, String... locations) {
    																//1.添加资源路径地址:META-INF/resource/wenjars
    																//2.添加默认访问资源文件夹地址:比如:classpath:public
			addResourceHandler(registry, pattern, (registration) -> registration.addResourceLocations(locations));
}
private void addResourceHandler(ResourceHandlerRegistry registry, String pattern,
				Consumer<ResourceHandlerRegistration> customizer) {
    		//1.判断这里是否注册了一个/webjars/**
    		//2.判断这里是否注册了一个/**
    		//说白了就是判断是否有效
			if (registry.hasMappingForPattern(pattern)) {
				return;
			}
    		//添加资源到webjars下的**目录
			ResourceHandlerRegistration registration = registry.addResourceHandler(pattern);
			customizer.accept(registration);
			registration.setCachePeriod(getSeconds(this.resourceProperties.getCache().getPeriod()));
			registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());
			registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified());
			customizeResourceHandlerRegistration(registration);
}
```

从可以上源码可以得出我们所有的`/webjars/**`都需要去`classpath:/META-IF/resources/webjars/`找对应的资源;

那什么是webjars呢?

#### 8.1.1 webjars

> 其实webjars本质就是以jar包的形式引入我们的静态资源!

我们以前要导入一个静态资源文件直接导入即可,而使用SpringBoot则需要使用Webjars去管理静态资源;

这是网站:https://www.webjars.org

而我们比如使用JQuery,我们只需要引入对应的版本pom依赖即可!

```xml-dtd
<dependency>
    <groupId>org.webjars</groupId>
    <artifactId>jquery</artifactId>
    <version>3.6.0</version>
</dependency>
```

然后我们找到对应依赖目录可以发现:

![image-20210921145653589](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921145653589.png)

说明jquery已经被引进来了,这jquery还是js只不过以jar包的方式给它封装了一层结构

而再回过头来再看:

![image-20210921150028981](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921150028981.png)

首先静态资源会在webjars下去找,符合这个`META-INF/resource/webjars这个结构下去找`就会被识别访问

我们现在在地址栏进行访问看SpringBoot是否会去对应路径下寻找静态资源:

```http
http://localhost:8085/webjars/jquery/3.6.0/jquery.js
```

这里路径的话前面localhost不多说了,而后面这个webjars是对应这个`/webjars/**`,我们只需要输入这个,因为他会映射这个地址`/META-INF/resources/webjars/`,所以我们只需要根据这个路径去获取就能获取到:

![image-20210921151044540](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921151044540.png)

以上是第一种能拿到静态资源的方式,但是弊端较大,假如我们要使用自己的静态资源该怎么导入呢?那么接下来是第二种:

#### 8.1.2 获取静态资源路径

我们再回到映射资源规则那里找到这句代码:

```java
this.mvcProperties.getStaticPathPattern()
```

这表示获取静态资源的路径,而具体是哪里的路径呢?我们再点击`getStaticPathPattern`进去看:

```java
public String getStaticPathPattern() {
		return this.staticPathPattern;
}
//再点击这个this.staticPathPattern
private String staticPathPattern = "/**";
```

这下就找到了,这表示是在**当前目录下的所有东西它都能被识别**

然后它会去找`resourceProperties`这个类,首先是通过:

```java
this.resourceProperties.getStaticLocations();
//点击跳转getStaticLocation

//进入方法
public String[] getStaticLocations() {
			return this.staticLocations;
}
//找到对应的值
private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
//找到路径
private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { "classpath:/META-INF/resources/",
				"classpath:/resources/", "classpath:/static/", "classpath:/public/" };
```

ResourceProperties可以设置和我们静态资源有关的参数(通过SpringBoot配置文件);这里面指向了它会去寻找资源的文件夹,也就是上面`CLASSPATH_RESOURCE_LOCATIONS`数组的内容;

**结论**:

以下四个目录存放的静态资源都可以被我们识别:

```java
1."classpath:/META-INF/resources/"
2."classpath:/resources/"
3."classpath:/static/"
4."classpath:/public/"
```

那么也就是说我们可以在resource根目录下新建以上对应的文件夹,存放我们的静态资源,那么我们在浏览器上输入`/**`就会去这些文件夹中寻找对应的静态资源文件;

现在测试是否访问到:

1. 在resources根目录下新建`public`文件夹然后再新建一个html:

   ![image-20210921155936243](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921155936243.png)
   
2. 浏览器访问:

   ![image-20210921160036689](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921160036689.png)

   **注意**:第一种方式跟webjars是一样的,也就是说我们可以通过这个的方式去访问webjars下的资源

   ![image-20210921161035561](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921161035561.png)

   ![image-20210921161046286](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921161046286.png)

   > 照着路径去匹配去查找

   **思考**:既然都能被识别,那么试想如果同时这些文件夹都存放`1.js`那么浏览器会加载哪个文件夹下的资源呢?

   1. 我在每个`1.js`里面都写这种格式"hello-文件夹名字"

   2. 来看下目录结构:

      ![image-20210921161250215](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921161250215.png)

   3. 地址栏访问:

      ![image-20210921161313651](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921161313651.png)

   **结论**:可以看出如果同时出现一样的情况下resource目录下的优先级是更高的!

   **思考**:那假如没有resources这个目录,那public跟static谁的优先级更高呢?

   这里我就不贴图了,直接给结论:

   > 三个目录的优先级:resources > static > public

#### 8.1.3 自定义资源路径

我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；

```properties
spring.mvc.static-path-pattern=/coding/,classpath:/miao/
```

一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！

```java
 if (!this.resourceProperties.isAddMappings()) {
        logger.debug("Default resource handling disabled");
        return;
    }
```

![image-20210921164347136](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921164347136.png)

### 8.2 总结

在SpringBoot中访问静态资源有两种方式:

1. 通过webjars的网站引入对应maven依赖,然后通过地址栏:localhost:8080/webjars/xxx进行访问
2. 通过内置的默认资源文件夹进行访问,比如:localhost:8080/xx,它就会以/**去找内置的文件夹下去找,如果出现一样的那么优先级为:resources > static > public

> 我们在创建项目的时候springBoot默认创建的是static文件夹,也就是说是默认访问的这个文件夹!

> 以上的东西都是来自于源码解析得出来的,是有理有据的!



## 9.首页源码

我们做一个网页是不是得有一个首页,京东淘宝都有自己的一个首页,而我们SpringBoot是如何去获取首页的映射关系呢?

1. 我们所有有关mvc的配置都在`WebMvcAutoConfiguration`这个配置类里;所以先进去这个类里面;

2. 然后找到`WelcomePageHandlerMapping`这个方法:

   ```java
   @Bean
   //这是一个欢迎页处理器映射方法
   public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
   				FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {
   			WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
                   																				//获取欢迎首页
   					new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),
   					this.mvcProperties.getStaticPathPattern());
       		//设置拦截器
   			welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
       		//设置Cors有关的配置
   			welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());
   			return welcomePageHandlerMapping;
   }
   ```

3. 然后我们点击`getWelcomePage()`这个方法里面去:

   ```java
   private Resource getWelcomePage() {
       		//获取内置资源文件夹的路径作为数组进行循环去获取首页
   			for (String location : this.resourceProperties.getStaticLocations()) {
                   //从这里获取getIndexHtml()点击去查看:
   				Resource indexHtml = getIndexHtml(location);
   				if (indexHtml != null) {
   					return indexHtml;
   				}
   			}
   			ServletContext servletContext = getServletContext();
   			if (servletContext != null) {
   				return getIndexHtml(new ServletContextResource(servletContext, SERVLET_LOCATION));
   			}
   			return null;
   }
   //跳转
   private Resource getIndexHtml(String location) {
   		return getIndexHtml(this.resourceLoader.getResource(location));
   }
   
   private Resource getIndexHtml(Resource location) {
   		try {
               //获取指定的index.html,
   				Resource resource = location.createRelative("index.html");
   				if (resource.exists() && (resource.getURL() != null)) {
   					return resource;
   				}
   			}
   		catch (Exception ex) {}
   		return null;
   }
   ```

   结论:静态资源文件夹下的所有index.html页面会被/**映射,比如我访问:http://localhost:8080/,此时就会去静态资源文件夹下去找是否有文件是index.html,也就是资源目录下的三个文件夹,如果找到就直接返回!

![image-20210921191415510](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921191415510.png)

​	**注意**:如果index.html放在template文件夹下是不会被识别到的,如果想要被识别是要从Controller跳转的,而跳转就需要依靠Thymeleaf模板引擎依赖

## 10.单元测试

**引入**:后续的学习过程中，每次都要写controller来访问测试比较麻烦，其他我们可以通过springboot的测试直接测试。就和原来不用启动tomcat一样测试

**导入依赖:**

```xml-dtd
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-test</artifactId>
</dependency>
```

测试:

```java
@RunWith(SpringRunner.class) 
@SpringBootTest(classes = App.class) //这事一个Spring测试，要告诉它在哪儿加载Spring配置文件，其实告诉它应用类型就ok,这个参数是将我们原本的主启动类的class
public class SpringbootTest {
	@Autowired
	private TestService testService;
	@Test
	public void test() throws Exception {
		System.out.println(testService);
		testService.test();
	}
}
```



## 11.事务传播方式

![image-20211009183946649](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211009183946649.png)

常用的是前4个,  REQUIRED 是默认的也是用得最多的:

- REQUIRED :支持当前事务,如果当前没有事务,则新建一个事务
- SUPPORTS :支持当前事务,当前当前没有事务,就不加事务
- REQUIRES_NEW :新建事务，如果当前有事务，则把事务挂起
- NEVER : 不支持事务,如果当前有事务,则抛出异常
- MANDATORY : 支持当前事务，如果当前没有事务，则抛出异常
- NOT_SUPPORTED ：不运势当前事务,如果当前存在事务，则把事务挂起
- NESTED ：支持当前事务，如果事务存在，则执行一个嵌套事务，如果事务不存在，就新建一个事务

## 12.跨域

**概念**:跨域是指跨域名,域名:记忆网络电脑ip很难记,就给它取了一个名字来记忆,这个名字就要域名,域名最终要被转换为ip.

比如:[www.baidu.com](http://www.baidu.com)被解析为IP地址就是185.15.15.14

> 跨域是指跨域名的访问,从一个域名的系统去访问另一个域名系统，以下情况都属于跨域

注意:域名是指IP+端口组成的!

![image-20211021111906032](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211021111906032.png)

> 只要是你域名或者端口不是一样那么就是跨域!

### 12.1 跨域问题

> 跨域不一定会有跨域问题!

因为跨域问题是浏览器`对于ajax请求的一种安全限制`：一个页面发起的ajax请求，只能是于当前页同域名的路径，这能有效的阻止跨站攻击。

因此:跨域问题就是浏览器针对ajax异步请求的一种限制!!

### 12.3 解决方案

目前比较常用的跨域解决方案有3种：

1. Json--json

   ```javascript
   最早的解决方案，利用动态去填充script标签可以跨域的原理实现
   <sccipt src=”http:/wwww/ssss”> --处理
   限制：
     - 需要服务的支持
     - 只能发起GET请求
   ```

2. nginx反向代理(部署)

   ```
   思路是：利用nginx反向代理把跨域为不跨域，支持各种请求方式
   缺点：需要在nginx进行额外配置，语义不清晰 --
   ```

   ![image-20211021115444368](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211021115444368.png)

3. CORS

   ```
   规范化的跨域请求解决方案，安全可靠。
   优势：
     - 在服务端进行控制是否允许跨域，可自定义规则
     - 支持各种请求方式
     缺点：
     - 会产生额外的请求,要做询问
   ```

### 12.4 CORS解决

概念:CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

CORS需要`浏览器`和`服务器`同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

1. 浏览器
   - 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器**自动完成**，不需要用户参与。
2. 服务器
   -  CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可

### 12.5 原理

浏览器会将ajax请求分为两类，其处理方案略有差异：**简单请求**、**特殊请求**。

#### 1.简单请求

```bash
只要同时满足以下两大条件,就属于简单请求:
(1)请求方法以下三种方法之一:
	1.HEAD
	2.GET
	3.POST
(2)HTTP的头信息不超过以下几种字段:
	- Accept
	- Accept-Language
	- Content-Language
	- Last-Event-ID
	- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
```

当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：Origin:

![image-20211022111759109](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211022111759109.png)

Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。如果服务器允许跨域，需要在返回的响应头中携带下面信息：

![image-20211022111844878](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211022111844878.png)

其中:

- Access-Control-Allow-Origin:可接受的域，是一个具体域名或者*，代表任意
- Access-Control-Allow-Credentials:是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true

#### 2.特殊请求

不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。

这里介绍一个名词"预检请求"

> ​	特殊请求会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

一个“预检”请求的样板：

​	![image-20211022112157566](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211022112157566.png)

与简单请求相比，除了Origin以外，多了两个头：

- Access-Control-Request-Method：接下来会用到的请求方式，比如PUT
- Access-Control-Request-Headers：会额外用到的头信息

预检请求的响应:

​	服务的收到预检请求，如果许可跨域，会发出响应：

![image-20211022112258191](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211022112258191.png)

除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头：

- Access-Control-Allow-Methods：允许访问的方式
- Access-Control-Allow-Headers：允许携带的头
- Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了询问-支持源地址跨域真实请求

![image-20211022112414410](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211022112414410.png)

### 12.6 跨域解决方案

#### 1.后台解决

虽然原理比较复杂，但是前面说过：

\- 浏览器端都有浏览器自动完成，我们无需操心

\- 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。

事实上，`SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter `,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class GlobalCorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        //1.添加CORS配置信息
        CorsConfiguration config = new CorsConfiguration();
        //1) 允许的域,不要写*，否则cookie就无法使用了
        config.addAllowedOrigin("http://127.0.0.1:8081");
        config.addAllowedOrigin("http://localhost:8081");
        config.addAllowedOrigin("http://127.0.0.1:80");
        config.addAllowedOrigin("http://localhost:80");
        config.addAllowedOrigin("http://127.0.0.1");
        config.addAllowedOrigin("http://localhost");


        //2) 是否发送Cookie信息
        config.setAllowCredentials(true);
        //3) 允许的请求方式
        config.addAllowedMethod("OPTIONS");
        config.addAllowedMethod("HEAD");
        config.addAllowedMethod("GET");
        config.addAllowedMethod("PUT");
        config.addAllowedMethod("POST");
        config.addAllowedMethod("DELETE");
        config.addAllowedMethod("PATCH");
        // 4）允许的头信息
        config.addAllowedHeader("*");
        //2.添加映射路径，我们拦截一切请求
        UrlBasedCorsConfigurationSource configSource = new
                UrlBasedCorsConfigurationSource();
        configSource.registerCorsConfiguration("/**", config);
        //3.返回新的CorsFilter.
        return new CorsFilter(configSource);
    }
}
```

#### 2.前台解决

如果是前端开发，多个项目之间有相互访问的情况(只能在vue-cli的项目可以解决)。

1. 在项目的config/index.js

   ```javascript
   proxyTable: {
       '/api': {
           target: 'http://localhost:8080',
           changeOrigin: true,
           pathRewrite: {
               '^/api': '' //类似于nginx反向代理所有以api开头的访问
           }
       }, 
   },
   ```

2. 在main.js中加入全局访问配置 为了不改变原来的访问，或者不需要每一次访问后台都要加上api

   ```javascript
   //配置axios的全局基本路径
   axios.defaults.baseURL='/api
   ```

   

