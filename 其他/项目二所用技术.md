# 使用到的技术

## 1. 图片上传-fastdfs

首先这是一个分布式文件系统

![image-20211027225924233](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211027225924233.png)

```
为什么需要分布式文件系统:

在使用Fastdfs之前的单体上传文件缺点:
	1. 图片上传和其他crud请求都在一个服务器进行处理,这样服务器压力会比较大
	2. 不能在集群环境中使用,每一个服务器磁盘都是独立的!
使用fastdfs的优点:
	1.存储量大,因为使用的是分布式集群服务器
	2.单点故障,因为在集群中任何一台服务器出现故障都不会影响整体的运行,效率得到提升

理解:因为在这之前我们服务器使用的是一种单体架构方式,所有请求都是一个服务器处理,图片上传也是上传到本地硬盘中进行存储!而随着项目的不断发展和推进,项目分裂出分布式服务器,那么这个时候文件如果还是用之前的文件上传,那么在集群环境中是不可行的,因为每一个服务器所在的磁盘都是独立的!所以我们需要使用一种分布式文件管理系统进行单独管理上传服务器!

为什么选择fastdfs:
	我们之所以选择它是因为首先它是一种开源的分布式文件系统,它具有高可用、高可靠、负载均衡、冗余备份、线性扩容等特点，它给我的使用感受呢就是存储量大，因为使用单独的服务器集群去管理存储，并且它还是单点故障，也就是说在集群中如果有一台服务器出现了故障那么文件管理系统依然还能运行！那么这就是高可用和高可靠！并且既然是集群那么肯定就是主从复制，主节点负责上传文件而从节点负责文件的读，如果并发量很大的情况下，我们还可以进行线性扩容从节点，这样达到了一个均衡的一个目的！
```

解释:

​	FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了`冗余备份`、`负载均衡`、`线性扩容`等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套`高性能的文件服务器集群`提供文件上传、下载等服务。

​	FastDFS 架构包括 **Tracker server** 和 **Storage server**。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。

每个部分的作用:

1. **Tracker server**
   - 作用是`负载均衡和任务调度`，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。
2. **Storage server**
   - 作用是`文件存储`，客户端上传的文件最终存储在 Storage 服务器上，Storage server 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。

**理解**:Fastdfs是一个分布式文件管理系统,是一种以负载均衡、冗余备份、线性扩容等机制的服务器集群,既然是集群那么也意味着是一种主从复制的结构,主机负责上传从机负责读这样极大的提高了程序的性能问题,因为一般读的时间大于写的时间,Fastdfs主要以`Trackert server`和`Storage server`,前者主要来接收文件上传根据相关策略来决定使用哪一个服务器进行存储,这也是一种负载均衡的机制!而Storage Server主要以存储为主,简单的可以理解为:前者来决定上传到哪一个服务器是一个决定者,而后者是负责存储的,

### 1.1 架构

![image-20211029155647214](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029155647214.png)

服务端两个角色:

- Tracker：`管理集群`，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。
- Storage：`实际保存文件`  Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念

相关地址:

- 官方网站：https://github.com/happyfish100/
- 配置文档：https://github.com/happyfish100/fastdfs/wiki/
- 参考资料：https://www.oschina.net/question/tag/fastdfs
- Java客户端：https://github.com/happyfish100/fastdfs-client-java

### 1.2 上传流程

![image-20211029155832268](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029155832268.png)

客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。

![image-20211029160000116](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029160000116.png)

其中：

- 组名（卷）：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。
- 虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了 store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推
- 数据两极目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。
- 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。

### 1.3 使用：

这是maven：

```xml
<!--fastdfs分布式文件管理系统-->
        <dependency>
            <groupId>cn.bestwu</groupId>
            <artifactId>fastdfs-client-java</artifactId>
            <version>1.27</version>
        </dependency>
```

添加配置文件fdfs_client.conf ，将其中的服务器地址设置为192.168.25.133

```c#
tracker_server=47.95.117.210:22122
```

这是封装的工具类:

```java
package cn.miao.basic.util;

import org.csource.common.NameValuePair;
import org.csource.fastdfs.*;

import java.net.URL;

/**
 * @program: backstageProject
 * @description: fastDfs工具类
 * @author: MiaoWei
 * @create: 2021-10-27 20:16
 **/
public class FastDfsUtil {
    private static final String CONF_FILENAME = "F:\\源码时代\\学习项目\\twoPoject\\backstageProject\\src\\main\\resources\\fdfs_client.conf";
    //从classpath
//    public static String CONF_FILENAME = FastDfsUtil.class.getClassLoader()
//            .getResource("fdfs_client.conf").getFile();


    public static void main(String[] args) {
        URL resource = FastDfsUtil.class.getClassLoader()
                .getResource("fdfs_client.conf");
        String resourceFile = resource.getFile();
        System.out.println("resourceFile = " + resourceFile);
    }
    /**
     * 上传文件
     *
     * @param file
     * @param extName
     * @return
     */
    public static String upload(byte[] file, String extName) {

        try {

            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            NameValuePair[] nvp = new NameValuePair[]{
                    new NameValuePair("age", "18"),
                    new NameValuePair("sex", "male")
            };
            String[] fileIds = storageClient.upload_file(file, extName, nvp);

//            System.out.println(fileIds.length);
//            System.out.println("组名：" + fileIds[0]); // group1
//            System.out.println("路径: " + fileIds[1]); // saldfj/sdfas/sdaf.jpg
            return "/" + fileIds[0] + "/" + fileIds[1];

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 上传文件
     *
     * @param extName
     * @return
     */
    public static String upload(String path, String extName) {

        try {
            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;
            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            String fileIds[] = storageClient.upload_file(path, extName, null);

//            System.out.println(fileIds.length);
//            System.out.println("组名：" + fileIds[0]);
//            System.out.println("路径: " + fileIds[1]);
            return "/" + fileIds[0] + "/" + fileIds[1];

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 下载文件
     *
     * @param groupName
     * @param fileName
     * @return
     */
    public static byte[] download(String groupName, String fileName) {
        try {

            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            byte[] b = storageClient.download_file(groupName, fileName);
            return b;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 删除文件
     *
     * @param groupName
     * @param fileName
     */
    public static void delete(String groupName, String fileName) {
        try {
            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer,
                    storageServer);
            int i = storageClient.delete_file(groupName, fileName);
            System.out.println(i == 0 ? "删除成功" : "删除失败:" + i);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("删除异常," + e.getMessage());
        }
    }
}
```

浏览器访问的是:[http://122.51.119.246:8888/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg](http://192.168.25.133/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg)

>  上传用22122端口
>
>  访问用8888端口



## 2.前端服务器

我们之前的前端使用的vue脚手架搭建起来的,所以可以使用npm run dev进行启动服务,而如果是纯HTML那么我们该如何去启动呢?如何方便我们调试呢?

```properties
# 安装
npm install -g live-server
# 启动,指定端口
live-server --port=80  
```

这种呢就是把当前路径下的web资源当做一个服务的内容启动起来，并可以指定端口

![image-20211029180035016](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029180035016.png)

## 3.三方登录

三方登录顾名思义就是使用第三方主流平台如:微信、QQ、支付宝等等;这样的好处就是免于我们繁杂的注册流程!

> 三方登录协议-OAuth2.0

`OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准`。与以往的授权方式不同之处是`OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码）`,即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写，目前的版本是2.0版。

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/wpsB55A.tmp.jpg)

这是官网地址:https://oauth.net/2/

理解:使用这种协议的好处就是不会去触及第三方用户的隐私性信息,如:密码等隐私性较高的东西!只会进行授权的操作拿到一些我们能够看见的东西

> OAuth的思路

​	OAuth在"客户端"与"服务提供商"之间，设置了一个`授权层`（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层使用的是令牌（token），与用户的密码不同。用户可以在登录的时候，指定令牌的权限范围和有效期。

"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。

> 运行流程

![image-20211101154816858](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101154816858.png)

步骤:

1. A: 用户打开客户端以后,客户端要求用户给予授权;
2. B: 用户同意给予客户端授权
3. C: 客户端使用上一步获取的授权,向认证服务器申请令牌,
4. D: 认证服务器对客户端进行认证以后,确认无误,同意发放令牌
5. E: 客户端使用令牌,向资源服务器申请获取资源
6. F: 资源服务器确认令牌无误,同意向客户端开放资源;

其实总的来说`token`是一个关键的东西,结合OAuth的思路来进行思考:客户端会首先发起一个授权界面,一旦用户同意了授权那么就可以申请获取token令牌,拿到token令牌以后就表示登录到客户端与服务提供商之间的`授权层`,而到了这一层,我们就可以根据令牌向服务提供商申请想要的资源,如:用户个人信息,服务提供商拿到这个令牌确认可以就开放对应的资源!

其实再缩减就是这三个步骤:**用户授权**、**获取令牌**、**访问受限资源**

**注意**：在上述六个步骤中，B是关键，因为用户无论怎样只要给客户端授权，客户端才能根据这个授权去获取令牌，进而凭借令牌来获取资源！

> 客户端授权-授权码模式

客户端必须得到用户的授权，才能获取令牌，那么OAuth定义了四种授权方式：

- 授权码模式
- 简化模式
  - 拿到授权二维码就可以直接放行
- 密码模式
  - 在获取的资源那里设置密码,所以不需要拿到授权和token就可以直接进入
- 客户端模式
  - 直接进我们想要的资源,根本不需要token和授权

这里主要介绍第一种方式:`授权码模式`

​	`授权模式是功能最完整、流程最严密的授权模式`,它的特点就是通过客户端的后台服务器与"服务提供商"的认证服务器进行互动,来看下一张图:

![image-20211101162020098](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101162020098.png)

流程:

A: 用户访问客户端,后者将前者导向认证服务器

B: 用户选择是否给予客户端授权

C: 假设用户给予授权,认证服务器将用户导向客户端实线指定的：“重定向URI”，同时附上一个授权码

D：客户端收到授权码，附上早先的"重定向URI",向认证服务器申请令牌。这一步是在客户端的后台服务器上完成的，对用户不可见。

E：认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access_token）和更新令牌(refresh_token)

> 网站微信登录原理

这是官方给出的文档:https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html

这是一个过程:

![image-20211101163030290](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101163030290.png)

> 核心代码实现:

步骤:

1. 用户点击第三方微信登录按钮,获取code授权码

   ```html
   <li><a href="https://open.weixin.qq.com/connect/qrconnect?appid=wxd853562a0548a7d0&redirect_uri=http://bugtracker.itsource.cn/callback.html&response_type=code&scope=snsapi_login&state=3#wechat_redirect"><i class="am-icon-weixin am-icon-sm"></i><span>微信登录</span> </a></li>
   ```

   ![image-20211101163547412](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101163547412.png)

   ​	其中`redirect_uri`表示的重定向的地址,微信第三方通过appid会返回一个授权二维码,需要用户扫码进行确认是否进行授权操作!

2. 跳转到重定向页面,此时http地址后跟着指定参数`code`,表示我们已经拿到了授权码了

   ```javascript
   mounted() {
       //注:本页面是回调页面,也就是说在login页面发起微信登录然后通过参数appid或回调重定向页面到本页面
       //回调到本页面会带1个参数: code授权码
       //解析参数上
       let url = location.href; // http://bugtracker.itsource.cn/callback.html?code=051p2m100kZ6GM1ge7100yhviD4p2m1m&state=3
   
       //  根据url生成对象
       let paramObj = parseUrlParams2Obj(url);
   
       //   let binderUrl="http://bugtracker.itsource.cn/binder.html";
       //封装请求参数
       let param = {"code": paramObj.code};
       // 发送请求
       this.$http.post("/user/wechat", param)
           .then(result => {
           //200表示免密登录成功
           if (result.data.code===200) {
               // 把用户信心保存到localStorage
               // alert("登录成功");
               //1.将token和登录信息存入localStorage
               let {token, loginfo} = result.data.data;
               localStorage.setItem("token", token);
               localStorage.setItem("loginInfo", JSON.stringify(loginfo));
               //2.跳转到首页，并显示登录信息
               location.href = "index.html";
           }else if(result.data.code===204){
               //其他信息表示是第一次登录那么应跳转到绑定页面
               //1.获取的openID和access_token放入localStorage
               let {access_token,openid} = result.data.data;
               localStorage.setItem("openid",openid );
               localStorage.setItem("access_token", access_token);
               //2.跳转到绑定界面
               location.href = "binder.html";
           }
       }) 
     }
   ```

3. 发起异步请求,将获取的授权码(code)通过后端服务器进行发起get请求获取到token令牌,登录到授权层

   ```java
   String WXCHAT_TOKEN_BY_CODE = "https://api.weixin.qq.com/sns/oauth2/access_token?appid={}&secret={}&code={}&grant_type=authorization_code";
   private String appid=wxd853562a0548a7d0;
   private String secret=4a5d5615f93f24bdba2ba8534642dbb6;
   
   @Override
   public AjaxResult loginWeChat(Map<String, String> map) {
       String response = HttpUtil.get(CharSequenceUtil.format(WXCHAT_TOKEN_BY_CODE, appid, secret, code));
   	...
        //其他业务   
   }
   
   ```

   在官方也有阐释:

   ![image-20211101164722343](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101164722343.png)

   通过这个我们就可以获取到token,就可以进入OAuth思路中客户端和服务提供商之间的"授权层",通过这个授权层我们就可以拿到我想要的对应的资源

4. 通过token令牌我们可以获取到指定的用户信息:

   ```java
   /**
   	* 微信获取用户个人信息
   */
   String WXCHAT_ACCESS_TOKEN = "https://api.weixin.qq.com/sns/userinfo?access_token={}&openid={}";
   
   public AjaxResult binderWxChat(BinderWeChatDto dto) {
       //这里token和openid都是上面获取到的
       String response = HttpUtil.get(CharSequenceUtil.format(WXCHAT_ACCESS_TOKEN, dto.getAccessToken(), dto.getOpenId())); 
   }
   ```

   官方这里简述:

   ![image-20211101165253027](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101165253027.png)

> 总的流程就是这样,就没有了

其实使用微信三方登录无非就三步:

1. 发起链接地址出现授权二维码让用户进行授权操作
2. 授权成功重定向指定页面拿到授权码code
3. 发起请求到后端服务器通过code获取到token
4. 通过token获取到用户个人信息!

> 注意:因为这个第三方登录需要300人民币才有资获取,所以这是使用源码的,而源码在注册的时候绑定了端口为80,所以我们必须也要启动端口为80,并且重定向是从服务器商进行重定向,所以我们的项目映射为公网才可以,因为是微信平台进行重定向所以我们需要将本地IP转为域名的方式,才能找得到!如果不改的话那么我们重定向12.0.0.1就会重定向到第三方平台的本机!

我们可以将当前ip进行封装为公网地址,在hosts文件修改:

![image-20211101171503950](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101171503950.png)

![image-20211101171605627](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101171605627.png)

