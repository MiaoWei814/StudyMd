# 笔记

## 1. 数据库三范式

范式就是规范，就是要遵守的原则。一般要遵守有三种范式

1. 1NF(1范式): 设计数据库表的列的时候，这些列不可拆分。 列的`原子性`，其实这种范式可以不用管，关系型数据库默认都满足
2. 2NF(2范式)：表中行是`唯一`，通常设计一个主键来实现
3. 3NF(3范式)： 如果一张表的数据能够通过其他表推导出来，不应该单独设计，通过外键的方式`关联查询`出来

**注意**:反3NF：正常情况来说，我们必须遵循3NF，但是有的时候我们为了增强查询效率，会设计一些冗余字段，变多表查询为单表查询。

**理解**:1范式就是说列具有原子性不能拆分了,比如状态0和1就不能再拆分了;2范式指一张表中两行数据不能完全重复;3范式说如果一张表的数据能够通过其他表得出那么此时就要通过关联来获取,对字段的冗余部分进行剔除!

## 2. 短信验证码发送流程

![image-20211030093112116](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030093112116.png)

​	**流程**:用户发送验证码,首先从通过手机号和业务绑定一个key,然后从Redis缓存中获取,如果获取到那么此时我们就对value进行拆分,获取我们设置的时间戳,然后我们就判断这个时间戳跟当前时间戳是否相差1分钟,也就是说判断用户是否存在1分钟内连续发送,如果存在连续发送那么就抛出异常非法信息,如果超过一分钟,那么并且此时我们是可以获取到的,那么就说明是在3分钟之内的,可能因为网络延迟等原因用户没有及时的收到短信,所以避免重复发送造成验证码不一致,所以这里就直接重置验证码的时间为3分钟,注意此时的value的时间戳也要得到更新,因为如果不更新下一次用户又重发那么获取value很明显已经过来时间戳那么又要重置3分钟;下一步告知用户验证码已发送,然后回到我们刚刚那个点如果在Redis获取验证码不存在那么就直接发送验证码然后存于Redis缓存,注意要先执行发送再执行放入缓存中,因为可能出现手机号发送失败,而造成验证码存于缓存中!

```bash
1.校验
 1.1 手机号不能为空
 1.2 手机号是否被注册 查询t_user表
2.判断验证码是否有效（3分钟），从redis中是否能拿到 key： business_register:15982495855
 2.1 如果拿到了 需要判断是否过了1分钟重发时间      value:  9527:14679321341313
  2.1.1 如果没有过重发时间,报错：请勿重发获取验证码  1*60*1000
  2.1.2 如果过了，使用上次的验证码====
 2.2 如果拿不到
  2.2.1 直接生成新的验证码  ===
3.存储redis 设置3分钟过期
4.发送短信通知客人 验证码是：9527 请在3分钟内使用
```

注:如果说用户在1分钟之后重新发送验证码,那么这里还有另一种想法,比如可以重新发送验证码然后替换之前在redis中的验证码,但是这样就会造成一个问题,用户就会收到两次验证码,不过后台存储的是最新的那个!而一旦替换存储在redis服务器中那么时效重置为3分钟!

## 3. 短信接口

短信验证，只有三大运营商具有短信发送的能力。要发送短信只有找三大运营，或者中间商。简单说就是要找第三方的短信平台。常见的有阿里云，京东智联云，乐讯通等等非常多,

我们项目中使用网建短信通：http://sms.webchinese.com.cn/Rates.shtml

注册以后查看API接口:

![image-20211030094516079](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030094516079.png)

![image-20211030094527470](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030094527470.png)

测试:

```xml-dtd
<!-- https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient -->
<dependency>
    <groupId>commons-httpclient</groupId>
    <artifactId>commons-httpclient</artifactId>
    <version>3.1</version>
</dependency>
```

```java
package cn.itsource.basic.util;

/**
 * 短信常量类
 */
public class SmsContants {

    //用户名
    public static final String UID = "xxx";
    //秘钥
    public static final String KEY = "yyyy";

}

package cn.itsource.basic.util;

import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.NameValuePair;
import org.apache.commons.httpclient.methods.PostMethod;

/**
 * 短信发送工具类
 */
public class SmsUtil {

    /**
     * 发送短信
     * @param phones 手机们 a,b
     * @param content 发送内容
     * @return 返回值
     */
    public static String  sendSms(String phones,String content){
        PostMethod post = null;
        try {
            HttpClient client = new HttpClient();
            post = new PostMethod("http://utf8.api.smschinese.cn");
            post.addRequestHeader("Content-Type","application/x-www-form-urlencoded;charset=utf8");//在头文件中设置转码
            NameValuePair[] data ={ new NameValuePair("Uid", SmsContants.UID),
                    new NameValuePair("Key", SmsContants.KEY),
                    new NameValuePair("smsMob",phones),
                    new NameValuePair("smsText",content)};
            post.setRequestBody(data);

            client.executeMethod(post);
            int statusCode = post.getStatusCode();
            System.out.println("statusCode:"+statusCode); //200 404 400
            String result = new String(post.getResponseBodyAsString().getBytes("utf8"));
            return result;

        } catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            if (post != null) {

                post.releaseConnection();
            }
        }
        return null;
    }

    public static void main(String[] args) {
        System.out.println(SmsUtil
                .sendSms("13330964748", "您的验证码为：8848"));
    }
}
```

> 其实发短信流程不复杂,第一步:通过点击链接进行注册,第二步通过注册我们有5条免费的短信和一个APIKey,第三步:根据官方示例copy过来进行修改,就可以发送!

## 4.token

**引入**:我们思考一下之前有状态的登录方案是什么?

`session`-登录之后要把登录状态保持下来,就用到tomcat的会话跟踪技术;

session往往跟Cokkie一起搭配使用,比较依赖于cookie里面的jessionid;

![image-20211101144519464](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101144519464.png)

**理解**:用户访问网站,如果是第一次登录那么就会创建一个cookie并将服务器创建好的session信息通过一个jessionid进行写入并进行保存到客户端的浏览器总,下一次访问的时候就可以携带cookie中的jessionID到服务器端查找session进而判断是否存在或有效,来决定是否登录!

**注意:**cookie是服务器端创建然后保存到浏览器的,session是一种会话技术!

**缺点:**

1. 随着项目不断演进,存放在服务器端的session就会变得庞大,占用一定的资源,服务器性能降低
2. cookie+session不支持APP环境,因为APP里面压根就没有cookie
3. cookie是存储在客户端,安全性较低,若清除cookie那么登录信息也就没有了!

> 解决方案:无状态方案-token方案

这是一种完全抛弃了session的方案,我们可以使用redis缓存机制来实现这个方案,因为redis缓存是一款高性能、高可用的缓存中间件!

**流程:**token其实就是由UUID进行生成的字符串,我们通常设置30分钟就到期来保持用户的登录信息,然后前端每次发起请求都带上token,后端拦截器进行判断是否存在token

这种方案与session方案的**好处**就在于:session是存放在服务器端,会造成服务器内存资源的占用较大,效率较低,影响服务器性能!而token使用的字符串的形式在单独的服务中进行存储,这种不仅提高了效率并且后面项目分裂为分布式集群的形式那么这种方案依然有效!而session的话就会变得不太友好!

### 4.1 浏览器存储技术

之前我们都知道浏览器进行存储的有`Cookie`;

**好处:**设置有效期,降低服务器压力

**缺点:**有大小限制,并且是存储在客户端不安全!

其实还有另外两种存储技术:`sessionStorage`和`localStorage`

sessionStorage:存放的数据只在当前窗口有效

localStorage:持久化存储。只要不删除，在当前浏览器永远有效

这是DEMO代码:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript">
        //sessionStorage 会话存储，当前窗口有效
        //localStorage 持久化存储，永远有效，只要不删除
        // function add() {
        //
        //     sessionStorage.setItem("user","{'name':'zs','age':18}")
        // }
        // function del() {
        //     sessionStorage.removeItem("user")
        // }
        // function update() {
        //     sessionStorage.setItem("user","{'name':'ls','age':18}")
        // }
        // function get() {
        //     alert(sessionStorage.getItem("user"));
        // }
        function add() {

            localStorage.setItem("user","{'name':'zs','age':18}")
        }
        function del() {
            localStorage.removeItem("user")
        }
        function update() {
            localStorage.setItem("user","{'name':'ls','age':18}")
        }
        function get() {
            alert(localStorage.getItem("user"));
        }
    </script>
</head>
<body>
  <input type="button" value="add" onclick="add()">
  <input type="button" value="del" onclick="del()">
  <input type="button" value="update" onclick="update()">
  <input type="button" value="get" onclick="get()">

</body>
</html>
```

客户端在这里:

![image-20211101151810061](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101151810061.png)



**注意:**

1. sessionStorage只是在单个网页窗口有效,一旦关闭则自动清除
2. LocalStoage是存储在浏览器本地,也就是换个窗口都是依然存在的,浏览器关闭然后再打开也是存在的!

3. 以上两种存储都是基于当前网站存储,所以可以看见对应的地址,如果换个网站比如现在打开京东网页,那么我们在当前项目保存的信息就不存在!

### 4.2 拦截器

怎么让token每次都携带过去:

1）登录成功后把token存放到浏览器，如果是移动端写文件。  localStorage

2）每次对后端的请求，都从浏览器获取token并且携带过去,对后端请求都是使用axios，使用axios前置拦截器给请求追加一个请求头

**核心:**其拦截器的核心,后端:一个拦截器获取token进行判断是否有效,前端三个拦截器:前置、后置、静态资源拦截器;

这里直接贴代码:

后端:

```java
@Configuration
public class WebConfigurer implements WebMvcConfigurer {
    @Autowired
    private LoginInterceptor loginInterceptor;
    /**
     * 添加拦截器
     *
     * @param registry 注册表
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor)
                //拦截所有请求
                .addPathPatterns("/**")
                //放行地址
                    //文件上传
                .excludePathPatterns("/fastDfs/**")
                    //用户门户网站端发起验证码、注册、登录
                .excludePathPatterns("/user/**")
                    //管理端店铺入驻、管理员登录
                .excludePathPatterns("/shop/**");
    }
}
@Component
public class LoginInterceptor implements HandlerInterceptor {
    @Autowired
    private RedisUtil redisUtil;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //获取前端请求中携带的token
        String token = request.getHeader("token");
        //为空则拦截,不为空则判断是否存在token
        if (CharSequenceUtil.isNotEmpty(token)) {
            //从缓存中是否能拿得到
            Object isExist = redisUtil.get(token);
            if (!Objects.isNull(isExist)) {
                //如果缓存中存在那么此时就重置失效时间
                redisUtil.expire(token, 60 * 30);
                return true;
            }
        }
        // TODO: 2021/10/30 拦截做处理
        throw new AccountExpiredException("您当前账户已过期,请重新登录!");
    }
}
```

前端:

```javascript
//前置拦截器,每次发起请求都会首先从这里开始拦截
//为了后端校验是否已经登录，只要用axios的请求都要携带token
//这个算前置拦截器
axios.interceptors.request.use(config => {
    //从本地存储空间获取这个token然后添加到请求中的headers里面给后端!
    let token = localStorage.getItem("token");
    if (token) {
        config.headers["token"] = token;  
    }
    return config;
}, error => {
    Promise.reject(error)
});

//这个是前端后置拦截器,在获取每一个请求的响应走这个拦截器
axios.interceptors.response.use(config=>{
    //如果在前置拦截器中没有token,后端就会拦截并返回这个状态
    if (config.data.code === 403) {
        localStorage.removeItem("token");
        localStorage.removeItem("logininfo");
        //跳转到指定路径path
        router.push({ path: '/login' });
    }
    return config;
},error => {
    Promise.reject(error)
})

// 静态资源拦截器,拦截页面请求path比如登录或者店铺注册就不拦截,其他访问静态资源如:path判断是不是有token,有则不拦截
//对页面跳转进行拦截!
router.beforeEach((to, from, next) => {
  //NProgress.start();
  if (to.path === '/login' || to.path==='/shopRegister') {
    localStorage.removeItem("token");
    localStorage.removeItem("logininfo");
    next(); //放行
    return; //不往下执行

  }
  let user = JSON.parse(localStorage.getItem('logininfo'));
  if (!user) {
    next({ path: '/login' })
  } else {
    next()
  }
})
```

> 拦截器的话也不复杂,就是每次请求前和响应后进行一个拦截,然后进行相应的处理!

访问资源流程分析:

![image-20211101152835590](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101152835590.png)

**理解**:用户请求axios异步请求,首先会经过前置拦截器,从本地存储技术中拿取token并设置到请求头信息中,然后请求到后端,此时后端就有一个后端拦截器,会对请求信息中的token判断是否能从redis中获取到,如果可以拿到那么设置刷新过期时间30分钟,并放行请求,如果获取不到那么就直接拦截下来并返回给前端报没有权限的异常信息,然后前端返回请求就会经过一个后置拦截器,分析返回的请求中是否是后端拦截报的异常,如果是那么就定位跳转到指定登录界面,如果不是照常放行!

